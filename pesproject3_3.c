
#include <stdlib.h>
#include <stdio.h>
#include "board.h"
#include "peripherals.h"
#include "pin_mux.h"                  //CALL THE HEADER FILES AND SETS OF LIBRARY FUNCTIONS
#include "clock_config.h"
#include "MKL25Z4.h"
#include "fsl_debug_console.h"
#include "logger.h"
#include "memory_test.h"
#include "led.h"


//PATERN GENERATION DEFINES FOR MERRAIN TWISTER RANDOM
//PATTERN GNERATION FUNCTION
#define UPPER_MASK		0x8000
#define LOWER_MASK		0x7fff
#define TEMPERING_MASK_B	0x9d2c
#define TEMPERING_MASK_C	0xefc60000
#define STATE_VECTOR_LENGTH 62
#define STATE_VECTOR_M      39 /* changes to STATE_VECTOR_LENGTH also require changes to this */

typedef struct tagMTRand                            //defining a structure data type of MTRand
{
    unsigned int mt[STATE_VECTOR_LENGTH];         //DEFINING THE ARRAY TO STORE THE PATTERN
    int index;                                  //using the index to specify the array elements
    //the value points to
} Random;

unsigned int length=4;                     // DEFINING THE SIZE OF THE BLOCK TO BE DYNAMICALLY
//ALLOCATED

extern unsigned int pat[100];      //INITIALIZING AN ARRAY PAT TO STORE THE RANDOM PATTERNS
//GENERATED BY RANDOM PATTERN GENERATOR
Random seedRand(unsigned int seed);
unsigned int genRandLong(Random* rand);  //PROTOTYPES OF ALL FUNCTIONS WHICH ARE
//INVOLVED IN GENERATING THE RANDOM PATTERN
unsigned int genRand(Random* rand);
void m_seedRand(Random* rand, unsigned int seed);
void gen_pattern(size_t length,unsigned int seed);


int main(void)
{
    /* Init board hardware. */
    BOARD_InitBootPins();
    BOARD_InitBootClocks();
    BOARD_InitBootPeripherals();
    /* Init FSL debug console. */
    BOARD_InitDebugConsole();
    //printf("hello");
    PRINTF("Hello World\n\r");

    LED_RED_INIT(1);
    LED_GREEN_INIT(1);   			//INITIALIZING THE LED INIT PINS
    LED_BLUE_INIT(1);





    //MEMORY TEST SUITE


    uint32_t *test_space = allocate_words(length);  //ALLOCATING THE ADDRESS OF THE BLOCK_POINTER
    //TO TEST SPACE

    //EXECUTING THE MEMORY TESTS WHICH HAS
    //FOLLOWING FUNCTIONS
    write_pattern( test_space,  length,  10); //CALLING WRITE PATTERN WHICH WRITES PATTERN TO
    //MEMORY LOCATION

    display_memory(test_space,length);   //CALLING THE MEMORY CONTENTS
    PRINTF("\n\r");

    verify_pattern( test_space, length, 10);  //VERIFY PATTERN TO CHECK IF THE MEMORY CONTENTS
    //MATCH THE CONTENTS OF THE ARRAY WHICH CONTAINS
    // THE RANDOMLY GENERATED PATTERN
    PRINTF("\n\r");



    write_memory(test_space,2,0xFFEE);		//WRITE TO MEMORY VALUE 0XFFEE AT OFFSET 2
    PRINTF("\n\r");
    display_memory(test_space,length);  //DISPLAY THE MEMORY CONTENTS OF THE BLOCK_POINTER
    PRINTF("\n\r");
    verify_pattern( test_space, length, 10); //VERIFY PATTERN TO CHECK IF THE MEMORY CONTENTS
    //MATCH THE CONTENTS OF THE ARRAY WHICH CONTAINS

    PRINTF("\n\r");
    PRINTF("\n\r");
    write_pattern( test_space,  length,  10);  //CALLING WRITE PATTERN WHICH WRITES PATTERN TO
    //MEMORY LOCATION
    PRINTF("\n\r");
    display_memory(test_space,length);     //DISPLAY THE MEMORY CONTENTS OF THE BLOCK_POINTER
    PRINTF("\n\r");
    verify_pattern( test_space, length, 10); //VERIFY PATTERN TO CHECK IF THE MEMORY CONTENTS
    //MATCH THE CONTENTS OF THE ARRAY WHICH CONTAINS
    PRINTF("\n\r");

    PRINTF("\n\r");                  //INVERT THE BUFFER_POINTER AT THE LOCATION WITH 1 OFFSET
    invert(test_space,1);
    PRINTF("\n\r");
    display_memory(test_space,length);  //DISPLAY THE MEMORY CONTENTS OF THE BLOCK_POINTER
    PRINTF("\n\r");
    verify_pattern(test_space, length, 10); //VERIFY PATTERN TO CHECK IF THE MEMORY CONTENTS
    //MATCH THE CONTENTS OF THE ARRAY WHICH CONTAINS

    PRINTF("\n\r");

    PRINTF("\n\r");
    invert(test_space,1);         //INVERT THE BUFFER_POINTER AT THE LOCATION WITH 1 OFFSET
    PRINTF("\n\r");
    display_memory(test_space,length); //DISPLAY THE MEMORY CONTENTS OF THE BLOCK_POINTER
    PRINTF("\n\r");
    verify_pattern( test_space, length, 10); //VERIFY PATTERN TO CHECK IF THE MEMORY CONTENTS
    //MATCH THE CONTENTS OF THE ARRAY WHICH CONTAINS

    PRINTF("\n\r");

    PRINTF("\n\r");
    get_address(test_space,3);      //GET ADDRESS OF A PARTICULAR OFFSET FROM LOCATION
    PRINTF("\n\r");
    free_words(test_space,length); //FREE BLOCK_POINTER
    LED_BLUE_OFF();
    LED_GREEN_ON();               //TURN THE LED GREEN ON
    LED_RED_OFF();

    PRINTF("\n\r");
    printf("\n\r");


    return 0 ;
}






void gen_pattern(size_t length,unsigned int seed)
{
    unsigned int i;            //GENERATE PATTERN FUNCTION WHICH STORES THE RANDOM PATTERN
    //IN THE PARTICULAR ARRAY

    Random r = seedRand(seed);
    for(i=0; i<length; i++)
    {
        pat[i]=genRand(&r);   //STORE THE RANDOM PATTERN IN ARRAY PAT

    }

}


void m_seedRand(Random* rand, unsigned int seed)
{
    rand->mt[0] = seed & 0xff;        //TAKE THE FIRST ELEMENT OF THE ARRAY MT OF VARIABLE
    //RAND AND DO BITWISE OPERATIONS TO GET A PARTICULAR SET OF VALUE
    for(rand->index=1; rand->index<STATE_VECTOR_LENGTH; rand->index++)
    {
        rand->mt[rand->index] = (6069 * rand->mt[rand->index-1]) & 0xff;
    }
}

/*
 Creates a new random number generator from a given seed.
*/
Random seedRand(unsigned int seed)
{
    //TAKE PARTICULAR VARIABLE OF STRUCTURE NAMED RAND AND
    //DO THE FOLLOWING OPERATIONS
    Random rand;
    m_seedRand(&rand, seed);  //CALL M_SEED TO DO A PARTICULAR SET OF OPERATIONS FOR PATTERN
    //GENERATION
    return rand;
}


/**
 * Generates a pseudo-randomly generated long.
 */
unsigned int genRandLong(Random* rand)
{

    unsigned int y;
    static unsigned int mag[2] = {0x0, 0x99};      /* mag[x] = x * 0x99 for x = 0,1 */
    if(rand->index >= STATE_VECTOR_LENGTH || rand->index < 0)
    {
        /* generate STATE_VECTOR_LENGTH words at a time */
        int kk;
        if(rand->index >= STATE_VECTOR_LENGTH+1 || rand->index < 0)
        {
            //CHECK IF RAND VARIABELS INDEX FALLS BETWEEN A
            //PARTICULAR RANGE AND DO PARTICULAR BITWSIE OPERATIONS
            //ON   THE ARRAY MT OF VARIABLE RAND
            m_seedRand(rand, 43);
        }
        for(kk=0; kk<STATE_VECTOR_LENGTH-STATE_VECTOR_M; kk++)
        {
            y = (rand->mt[kk] & UPPER_MASK) | (rand->mt[kk+1] & LOWER_MASK);
            rand->mt[kk] = rand->mt[kk+STATE_VECTOR_M] ^ (y >> 1) ^ mag[y & 0x1];
        }                                         //CHECK FOR THE ARRAY MT IF IT FALLS BETWEEN A SET OF VALUES
        //IF IT DOES THEN WE DO BITWISE OPERATION AT THOSE VALUES
        for(; kk<STATE_VECTOR_LENGTH-1; kk++)
        {
            //CHECK FOR THE ARRAY MT IF IT FALLS BETWEEN A SET OF VALUES
            //IF IT DOES THEN WE DO BITWISE OPERATION AT THOSE VALUES
            y = (rand->mt[kk] & UPPER_MASK) | (rand->mt[kk+1] & LOWER_MASK);
            rand->mt[kk] = rand->mt[kk+(STATE_VECTOR_M-STATE_VECTOR_LENGTH)] ^ \
                           (y >> 1) ^ mag[y & 0x1];
        }                                             //CHECK FOR THE ARRAY MT IF IT FALLS BETWEEN A SET OF VALUES
        //IF IT DOES THEN WE DO BITWISE OPERATION AT THOSE VALUES
        y = (rand->mt[STATE_VECTOR_LENGTH-1] & UPPER_MASK) | (rand->mt[0] & LOWER_MASK);
        rand->mt[STATE_VECTOR_LENGTH-1] = rand->mt[STATE_VECTOR_M-1] ^ (y >> 1) ^ mag[y & 0x1];
        rand->index = 0;
    }
    y = rand->mt[rand->index++];				//DO THE MERRIAN TWISTER ALGORITHM ON THE SET OF VALUES OF THE ARRAY
    y ^= (y >> 11);
    y ^= (y << 7) & TEMPERING_MASK_B;
    y ^= (y << 15) & TEMPERING_MASK_C;
    y ^= (y >> 18);
    return y;
}

/**
 * Generates a pseudo-randomly generated double in the range [0..1].
 */
unsigned int genRand(Random* rand)				//CONVERT THE GENRANDLONG INTO AN UNSIGNED  FORM AND GET THE 8 BIT
//RANDOM PATTERN
{
    return(genRandLong(rand) / 0xfffff);
}


